"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const linq = require("lazy-linq-with-types");
const exception_1 = require("./exception");
function random() {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < 16; i++)
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    return text;
}
class Db {
    constructor(server, tables) {
        this.state = "CLOSED";
        this.server = server;
        this.tables = tables;
        this.pkeySequences = Object.keys(tables).reduce((acc, tableName) => (Object.assign({}, acc, { [tableName]: parseInt(tables[tableName].orderBy(t => t.__id).last().__id) })), {});
    }
    __data() {
        return this.tables;
    }
    beginTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            this.rollback = this.rollback || this.tables;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = "CLOSED";
        });
    }
    commitTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            this.rollback = undefined;
        });
    }
    delete(tableSelector, selector) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = tableSelector(this.tables);
            this.tables = Object.keys(this.tables).reduce((acc, tableName) => (Object.assign({}, acc, { [tableName]: this.tables[tableName] === table
                    ? table.where(row => !selector(row))
                    : this.tables[tableName] })), {});
        });
    }
    rollbackTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            this.tables =
                this.rollback ||
                    exception_1.default(`Cannot call endTransaction when there is no active transaction.`);
        });
    }
    dropTable(tableSelector) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = tableSelector(this.tables);
            this.tables = Object.keys(this.tables).reduce((acc, tableName) => (Object.assign({}, acc, { [tableName]: this.tables[tableName] === table
                    ? linq.asEnumerable([])
                    : this.tables[tableName] })), {});
        });
    }
    //TODO: Remove cast
    //Spread on generics is not supported yet.
    //https://github.com/Microsoft/TypeScript/issues/10727
    insert(tableSelector, item) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = tableSelector(this.tables);
            const tableName = this.__getTableName(table);
            const items = [
                Object.assign({}, item, { __id: this.__updateNextId(table) })
            ];
            this.tables = Object.keys(this.tables).reduce((acc, tableName) => (Object.assign({}, acc, { [tableName]: this.tables[tableName] === table
                    ? table.concat(items)
                    : this.tables[tableName] })), {});
            return this.pkeySequences[tableName];
        });
    }
    insertMany(tableSelector, rows) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = tableSelector(this.tables);
            const tableName = this.__getTableName(table);
            const items = rows.map(i => (Object.assign({}, i, { __id: this.__updateNextId(table) })));
            this.tables = Object.keys(this.tables).reduce((acc, tableName) => (Object.assign({}, acc, { [tableName]: this.tables[tableName] === table
                    ? table.concat(items)
                    : this.tables[tableName] })), {});
            return this.tables[tableName]
                .orderBy(x => x.__id)
                .reverse()
                .take(rows.length)
                .select(x => x.__id)
                .toArray();
        });
    }
    update(tableSelector, selector, props) {
        return __awaiter(this, void 0, void 0, function* () {
            const table = tableSelector(this.tables);
            this.tables = Object.keys(this.tables).reduce((acc, tableName) => (Object.assign({}, acc, { [tableName]: this.tables[tableName] === table
                    ? table.select(row => selector(row) ? Object.assign({}, row, props) : row)
                    : this.tables[tableName] })), {});
        });
    }
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            this.state = "OPEN";
        });
    }
    __getTableName(table) {
        const tableName = Object.keys(this.tables).find(name => this.tables[name] === table);
        return tableName || exception_1.default(`Cannot find table.`);
    }
    __updateNextId(table) {
        const tableName = this.__getTableName(table);
        if (tableName) {
            const nextId = this.pkeySequences[tableName] + 1;
            this.pkeySequences = Object.keys(this.pkeySequences).reduce((acc, name) => (Object.assign({}, acc, { [name]: name === tableName ? nextId : this.pkeySequences[name] })), {});
            return nextId;
        }
        else {
            throw new Error(`Could not find table in database.`);
        }
    }
}
exports.default = Db;
//# sourceMappingURL=db.js.map